---
title: 【转】SQL标准中对事务的4个隔离级别
date: 2022-05-11 16:32:56
tags: 
- mysql
categories:
- mysql笔记

---
### SQL标准中对事务的4个隔离级别

这4种级别包括了：
<!--more-->
**read uncommitted（读未提交）**不允许发生脏写,也就是说，不可能两个事务在没提交的情况下去更新同一行数据的值，但是在这种隔离级别下，可能发生脏读，不可重复读，幻读。

***read committed（读已提交）***这个级别下，不会发生脏写和脏读,也就是说，人家事务没提交的情况下修改的值，你是绝对读不到的！但是呢，可能会发生不可重复读和幻读问题，因为一旦人家事务修改了值然后提交了，你事务是会读到的，所以可能你多次读到的值是不同的！有点骚气的简写名词，就是**RC**，一般如果你在公司里做开发，有个其他团队的兄弟讨论技术方案的时候，跟你来了句，把事务隔离级别设置成RC！这个时候你不要目瞪口呆，知道是读已提交级别就行了。

***repeatable read（可重复读）***这个级别下，不会发生脏写、脏读和不可重复读的问题，因为你一个事务多次查询一个数据的值，哪怕别的事务修改了这个值还提交了，没用，你不会读到人家提交事务修改过的值，你事务一旦开始，多次查询一个值，会一直读到同一个值！**RR级别保证你不会读到人家已经提交的事务修改过的值！但是他还是会发生幻读的**

**serializable（串行化）**这种级别，根本就不允许你多个事务并发执行，只能串行起来执行，先执行事务A提交，然后执行事务B提交，接着执行事务C提交，所以此时你根本不可能有幻读的问题，因为事务压根儿都不并发执行！

但是这种级别一般除非脑子坏了，否则更不可能设置了，因为多个事务串行，那数据库很可能一秒并发就只有几十了，性能会极差的。

### MySQL是如何支持4种事务隔离级别的？Spring事务注解是如何设置的？

MySQL默认设置的事务隔离级别，**都是RR级别的**，而且***MySQL的RR级别是可以避免幻读发生的***。

这点是MySQL的RR级别的语义跟SQL标准的RR级别不同的，毕竟SQL标准里规定RR级别是可以发生幻读的，但是MySQL的RR级别避免了！

也就是说，***MySQL里执行的事务，默认情况下不会发生脏写、脏读、不可重复读和幻读的问题***，事务的执行都是并行的，大家互相不会影响，我不会读到你没提交事务修改的值，即使你修改了值还提交了，我也不会读到的，即使你插入了一行值还提交了，我也不会读到的，总之，事务之间互相都完全不影响！

当然，要做到这么神奇和牛叉的效果，MySQL是下了苦功夫的，后续我们接着就要讲解**MySQL里的MVCC机制**，就是多版本并发控制隔离机制，***依托这个MVCC机制，就能让RR级别避免不可重复读和幻读的问题***。

然后给大家说一下，假设你要修改MySQL的默认事务隔离级别，是下面的命令，可以设置级别为不同的level，level的值可以是REPEATABLE READ，READ COMMITTED，READ UNCOMMITTED，SERIALIZABLE几种级别。

***SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;***

但是一般来说，真的其实不用修改这个级别，就用默认的RR其实就特别好，保证你每个事务跑的时候都没人干扰，何乐而不为呢？

另外，给大家说一下，假设你在开发业务系统的时候，比如用Spring里的@Transactional注解来做事务这块，假设某个事务你就是有点手痒痒，就想给弄成RC级别，你就想读到人家已经提交事务修改过的值，好，那么没问题。

在@Transactional注解里是有一个isolation参数的，里面是可以设置事务隔离级别的，具体的设置方式如下：

**@Transactional(isolation=Isolation.DEFAULT)**，然后默认的就是DEFAULT值，这个就是MySQL默认支持什么隔离级别就是什么隔离级别。

那MySQL默认是RR级别，自然你开发的业务系统的事务也都是RR级别的了。

但是你可以手动改成***Isolation.READ_UNCOMMITTED***级别，此时你就可以读到人家没提交事务修改的值了，够坑的！估计一般没人自己坑自己吧！

也可以改成***Isolation.READ_COMMITTED***，***Isolation.REPEATABLE_READ***，***Isolation.SERIALIZABLE***几个级别，都是可以的。

但是再次提醒，其实默认的RR隔离机制挺好的，真的没必要去修改，除非你一定要在你的事务执行期间多次查询的时候，必须要查到别的已提交事务修改过的最新值，那么此时你的业务有这个要求，你就把Spring的事务注解里的隔离级别设置为Isolation.READ_COMMITTED级别，偶尔可能也是有这种需求的。
<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.113.0"><link rel="shortcut icon" type=image/x-icon href="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><link rel=icon type=image/x-icon href="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><link rel=icon type=image/png sizes=16x16 href="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><link rel=icon type=image/png sizes=32x32 href="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><link rel=apple-touch-icon sizes=180x180 href="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><meta itemprop=name content="【转】理解MVCC机制"><meta itemprop=description content="好记性不如烂笔头..."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://avatars.githubusercontent.com/u/122615952?s=400&u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&v=4"><meta itemprop=keywords content="mysql"><meta property="og:type" content="article"><meta property="og:title" content="【转】理解MVCC机制"><meta property="og:description" content="好记性不如烂笔头..."><meta property="og:image" content="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://b.sxz799.fun/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="青丝蘸白雪i"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="青丝蘸白雪i"><meta property="article:published_time" content="2022-05-11 16:33:42 +0000 UTC"><meta property="article:modified_time" content="2022-05-11 16:33:42 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.df155ae781e4bac8f4cf613fdb817af646eb609c549c9914d3e5371f95fcffa8.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:""}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6","permalink":"https://b.sxz799.fun/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/","title":"【转】理解MVCC机制","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>【转】理解MVCC机制 - 青丝蘸白雪i</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>青丝蘸白雪i</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>82</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#理解mvcc机制的前奏undo-log版本链是个什么东西>理解MVCC机制的前奏：undo log版本链是个什么东西？</a></li><li><a href=#基于undo-log多版本链条实现的readview机制到底是什么>基于undo log多版本链条实现的ReadView机制，到底是什么？</a></li><li><a href=#read-committed隔离级别是如何基于readview机制实现的>Read Committed隔离级别是如何基于ReadView机制实现的？</a></li><li><a href=#mysql最牛的rr隔离级别是如何基于readview机制实现的>MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li><li><a href=#梳理一下数据库的多事务并发运行的隔离机制>梳理一下数据库的多事务并发运行的隔离机制</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=青丝蘸白雪i src=/imgs/img-lazy-loading.gif data-src="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><p class=site-author-name itemprop=name>青丝蘸白雪i</p><div class=site-description itemprop=description>好记性不如烂笔头...</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>82</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>49</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/sxz799 title="Github → https://github.com/sxz799" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities title="知乎 → https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2019-03-13T21:53:21+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=143572></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=326></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-08-02T21:48:06+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://b.sxz799.fun/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="https://avatars.githubusercontent.com/u/122615952?s=400&amp;u=56cff26ea3cc4e5d4fc20641962cb066ea3c3c48&amp;v=4"><meta itemprop=name content="青丝蘸白雪i"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="青丝蘸白雪i"><meta itemprop=description content="好记性不如烂笔头..."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="【转】理解MVCC机制"><meta itemprop=description content="理解MVCC机制的前奏：undo log版本链是个什么东西？
简单来说呢，我们每条数据其实都有两个隐藏字段，一个是trx_id，一个是roll_pointer，这个trx_id就是最近一次更新这条数据的事务id，roll_pointer就是指向你了你更新这个事务之前生成的undo log"></span><header class=post-header><h1 class=post-title itemprop="name headline">【转】理解MVCC机制</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-05-11 16:33:42 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-05-11 16:33:42 +0000 UTC">2022-05-11</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/mysql%E7%AC%94%E8%AE%B0 itemprop=url rel=index><span itemprop=name>mysql笔记</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>7365</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=评论><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>评论：</span>
<span class=waline-comment-count data-path=/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=理解mvcc机制的前奏undo-log版本链是个什么东西>理解MVCC机制的前奏：undo log版本链是个什么东西？</h3><p>简单来说呢，我们每条数据其实都有两个隐藏字段，一个是trx_id，一个是roll_pointer，这个trx_id就是最近一次更新这条数据的事务id，roll_pointer就是指向你了你更新这个事务之前生成的undo log</p><p>我们给大家举个例子，现在假设有一个事务A（id=50），插入了一条数据，那么此时这条数据的隐藏字段以及指向的undo log如下图所示，插入的这条数据的值是值A，因为事务A的id是50，所以这条数据的txr_id就是50，roll_pointer指向一个空的undo log，因为之前这条数据是没有的。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111449281.png alt></p><p>接着假设有一个事务B跑来修改了一下这条数据，把值改成了值B ，事务B的id是58，那么此时更新之前会生成一个undo log记录之前的值，然后会让roll_pointer指向这个实际的undo log回滚日志，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111449400.png alt></p><p>大家看上图是不是觉得很有意思？事务B修改了值为值B，此时表里的那行数据的值就是值B了，那行数据的txr_id就是事务B的id，也就是58，roll_pointer指向了undo log，这个undo log就记录你更新之前的那条数据的值。</p><p>所以大家看到roll_pointer指向的那个undo log，里面的值是值A，txr_id是50，因为undo log里记录的这个值是事务A插入的，所以这个undo log的txr_id就是50，我还特意把表里的那行数据和undo log的颜色弄成不一样的，以示区分。</p><p>接着假设事务C又来修改了一下这个值为值C，他的事务id是69，此时会把数据行里的txr_id改成69，然后生成一条undo log，记录之前事务B修改的那个值</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111450467.png alt></p><p>我们在上图可以清晰看到，数据行里的值变成了值C，txr_id是事务C的id，也就是69，然后roll_pointer指向了本次修改之前生成的undo log，也就是记录了事务B修改的那个值，包括事务B的id，同时事务B修改的那个undo log还串联了最早事务A插入的那个undo log，如图所示，过程很清晰明了。</p><p>所以这就是今天要给大家讲的一点，大家先不管多个事务并发执行是如何执行的，起码先搞清楚一点，就是多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段txr_id和roll_pointer，同时之前多个数据快照对应的undo log，会通过roll_pinter指针串联起来，形成一个重要的版本链！</p><h3 id=基于undo-log多版本链条实现的readview机制到底是什么>基于undo log多版本链条实现的ReadView机制，到底是什么？</h3><p>执行一个事务的时候，就给你生成一个ReadView，里面比较关键的东西有4个</p><ul><li>一个是m_ids，这个就是说此时有哪些事务在MySQL里执行还没提交的；</li><li>一个是min_trx_id，就是m_ids里最小的值；</li><li>一个是max_trx_id，这是说mysql下一个要生成的事务id，就是最大事务id；</li><li>一个是creator_trx_id，就是你这个事务的id</li></ul><p>那么现在我们来举个例子，让大家通过例子来理解这个ReadView是怎么用的</p><p>假设原来数据库里就有一行数据，很早以前就有事务插入过了，事务id是32，他的值就是初始值，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111529109.png alt></p><p>接着呢，此时两个事务并发过来执行了，一个是事务A（id=45），一个是事务B（id=59），事务B是要去更新这行数据的，事务A是要去读取这行数据的值的，此时两个事务如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111530575.png alt></p><p>现在事务A直接开启一个ReadView，这个ReadView里的m_ids就包含了事务A和事务B的两个id，45和59，然后min_trx_id就是45，max_trx_id就是60，creator_trx_id就是45，是事务A自己。</p><p>这个时候事务A第一次查询这行数据，会走一个判断，就是判断一下当前这行数据的txr_id是否小于ReadView中的min_trx_id，此时发现txr_id=32，是小于ReadView里的min_trx_id就是45的，说明你事务开启之前，修改这行数据的事务早就提交了，所以此时可以查到这行数据，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111530164.png alt></p><p>接着事务B开始动手了，他把这行数据的值修改为了值B，然后这行数据的txr_id设置为自己的id，也就是59，同时roll_pointer指向了修改之前生成的一个undo log，接着这个事务B就提交了，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111531724.png alt></p><p>这个时候事务A再次查询，此时查询的时候，会发现一个问题，那就是此时数据行里的txr_id=59，那么这个txr_id是大于ReadView里的min_txr_id(45)，同时小于ReadView里的max_trx_id（60）的，说明更新这条数据的事务，很可能就跟自己差不多同时开启的，于是会看一下这个txr_id=59，是否在ReadView的m_ids列表里？</p><p>果然，在ReadView的m_ids列表里，有45和59两个事务id，直接证实了，这个修改数据的事务是跟自己同一时段并发执行然后提交的，所以对这行数据是不能查询的！</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111532342.png alt></p><p>那么既然这行数据不能查询，那查什么呢？</p><p>简单，顺着这条数据的roll_pointer顺着undo log日志链条往下找，就会找到最近的一条undo log，trx_id是32，此时发现trx_id=32，是小于ReadView里的min_trx_id（45）的，说明这个undo log版本必然是在事务A开启之前就执行且提交的。</p><p>好了，那么就查询最近的那个undo log里的值好了，这就是undo log多版本链条的作用，他可以保存一个快照链条，让你可以读到之前的快照值，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111533950.png alt></p><p>看到这里，大家有没有觉得很奇妙？多个事务并发执行的时候，事务B更新的值，通过这套<strong>ReadView+undo log</strong>日志链条的机制，就可以保证事务A不会读到并发执行的事务B更新的值，只会读到之前最早的值。</p><p>接着假设事务A自己更新了这行数据的值，改成值A，trx_id修改为45，同时保存之前事务B修改的值的快照，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111534024.png alt></p><p>此时事务A来查询这条数据的值，会发现这个trx_id=45，居然跟自己的ReadView里的creator_trx_id（45）是一样的，说明什么？</p><p>说明这行数据就是自己修改的啊！自己修改的值当然是可以看到的了！如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111534374.png alt></p><p>接着在事务A执行的过程中，突然开启了一个事务C，这个事务的id是78，然后他更新了那行数据的值为值C，还提交了，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111535749.png alt></p><p>这个时候事务A再去查询，会发现当前数据的trx_id=78，大于了自己的ReadView中的max_trx_id（60），此时说明什么？</p><p>说明是这个事务A开启之后，然后有一个事务更新了数据，自己当然是不能看到的了！</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111536776.png alt></p><p>此时就会顺着undo log多版本链条往下找，自然先找到值A自己之前修改的过的那个版本，因为那个trx_id=45跟自己的ReadView里的creator_trx_id是一样的，所以此时直接读取自己之前修改的那个版本，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111536869.png alt></p><p>通过undo log多版本链条，加上你开启事务时候生产的一个ReadView，然后再有一个查询的时候，根据ReadView进行判断的机制，你就知道你应该读取哪个版本的数据。</p><p>而且他可以保证你只能读到你事务开启前，别的提交事务更新的值，还有就是你自己事务更新的值。假如说是你事务开启之前，就有别的事务正在运行，然后你事务开启之后 ，别的事务更新了值，你是绝对读不到的！或者是你事务开启之后，比你晚开启的事务更新了值，你也是读不到的！</p><p>通过这套机制就可以实现多个事务并发执行时候的数据隔离。</p><h3 id=read-committed隔离级别是如何基于readview机制实现的>Read Committed隔离级别是如何基于ReadView机制实现的？</h3><p>RC隔离级别，实际上意思就是说你事务运行期间，只要别的事务修改数据还提交了，你就是可以读到人家修改的数据的，所以是会发生不可重复读的问题，包括幻读的问题，都会有的。</p><p>所谓的ReadView机制，之前我们讲过，他是基于undo log版本链条实现的一套读视图机制，他意思就是说你事务生成一个ReadView，然后呢，如果是你事务自己更新的数据，自己是可以读到的，或者是在你生成ReadView之前提交的事务修改的值，也是可以读取到的。但是如果是你生成ReadView的时候，就已经活跃的事务，在你生成ReadView之后修改了数据，接着提交了，此时你是读不到的，或者是你生成ReadView以后再开启的事务修改了数据，还提交了，此时也是读不到的。</p><p>如何基于ReadView机制来实现RC隔离级别呢？</p><p>其实这里的一个非常核心的要点在于，当你一个事务设置他处于RC隔离级别的时候，他是每次发起查询，都重新生成一个ReadView！</p><p>首先假设我们的数据库里有一行数据，是事务id=50的一个事务之前就插入进去的，然后现在呢，活跃着两个事务，一个是事务A（id=60），一个是事务B（id=70），此时如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111556922.png alt></p><p>现在的情况就是，事务B发起了一次update操作，更新了这条数据，把这条数据的值修改为了值B，所以此时数据的trx_id会变为事务B的id=70，同时会生成一条undo log，由roll_pointer来指向，看下图：</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111557592.png alt></p><p>这个时候，事务A要发起一次查询操作，此时他一发起查询操作，就会生成一个ReadView，此时ReadView里的min_trx_id=60，max_trx_id=71，creator_trx_id=60，此时如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111557809.png alt></p><p>这个时候事务A发起查询，发现当前这条数据的trx_id是70。也就是说，属于ReadView的事务id范围之间，说明是他生成ReadView之前就有这个活跃的事务，是这个事务修改了这条数据的值，但是此时这个事务B还没提交，所以ReadView的m_ids活跃事务列表里，是有[60, 70]两个id的，所以此时根据ReadView的机制，此时事务A是无法查到事务B修改的值B的。</p><p>接着就顺着undo log版本链条往下查找，就会找到一个原始值，发现他的trx_id是50，小于当前ReadView里的min_trx_id，说明是他生成ReadView之前，就有一个事务插入了这个值并且早就提交了，因此可以查到这个原始值，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111559576.png alt></p><p>接着，咱们假设事务B此时就提交了，好了，那么提交了就说明事务B不会活跃于数据库里了，是不是？可以的，大家一定记住，事务B现在提交了。那么按照RC隔离级别的定义，事务B此时一旦提交了，说明事务A下次再查询，就可以读到事务B修改过的值了，因为事务B提交了。</p><p>那么到底怎么让事务A能够读到提交的事务B修改过的值呢？</p><p>很简单，就是让事务A下次发起查询，再次生成一个ReadView。此时再次生成ReadView，数据库内活跃的事务只有事务A了，因此min_trx_id是60，mac_trx_id是71，但是m_ids这个活跃事务列表里，只会有一个60了，事务B的id=70不会出现在m_ids活跃事务列表里了，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111600256.png alt></p><p>此时事务A再次基于这个ReadView去查询，会发现这条数据的trx_id=70，虽然在ReadView的min_trx_id和max_trx_id范围之间，但是此时并不在m_ids列表内，说明事务B在生成本次ReadView之前就已经提交了。</p><p>那么既然在生成本次ReadView之前，事务B就已经提交了，就说明这次你查询就可以查到事务B修改过的这个值了，此时事务A就会查到值B，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111600054.png alt></p><p>到此为止，RC隔离级别如何实现的，大家应该就理解了，他的关键点在于每次查询都生成新的ReadView，那么如果在你这次查询之前，有事务修改了数据还提交了，你这次查询生成的ReadView里，那个m_ids列表当然不包含这个已经提交的事务了，既然不包含已经提交的事务了，那么当然可以读到人家修改过的值了。</p><h3 id=mysql最牛的rr隔离级别是如何基于readview机制实现的>MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h3><p>今天来接着给大家讲解，MySQL中最牛的RR隔离级别，是如何同时避免不可重复读问题和幻读问题的。</p><p>其实大家现在应该都知道，在MySQL中让多个事务并发运行的时候能够互相隔离，避免同时读写一条数据的时候有影响，是依托undo log版本链条和ReadView机制来实现的。</p><p>上次我们都讲过了，基于ReadView机制可以实现RC隔离级别，即你每次查询的时候都生成一个ReadView，这样的话，只要在你这次查询之前有别的事务提交了，那么别的事务更新的数据，你是可以看到的。</p><p>那么如果是RR级别呢？RR级别下，你这个事务读一条数据，无论读多少次，都是一个值，别的事务修改数据之后哪怕提交了，你也是看不到人家修改的值的，这就避免了不可重复读的问题。</p><p>同时如果别的事务插入了一些新的数据，你也是读不到的，这样你就可以避免幻读的问题。</p><p>那么到底是如何实现的呢？我们今天来看看。</p><p>首先我们还是假设有一条数据是事务id=50的一个事务插入的，同时此时有事务A和事务B同时在运行，事务A的id是60，事务B的id是70，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111603698.png alt></p><p>这个时候，事务A发起了一个查询，他就是第一次查询就会生成一个ReadView，此时ReadView里的creator_trx_id是60，min_trx_id是60，max_trx_id是71，m_ids是[60, 70]，此时ReadView如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111604239.png alt></p><p>这个时候事务A基于这个ReadView去查这条数据，会发现这条数据的trx_id为50，是小于ReadView里的min_trx_id的，说明他发起查询之前，早就有事务插入这条数据还提交了，所以此时可以查到这条原始值的，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111607610.png alt></p><p>接着就是事务B此时更新了这条数据的值为值B，此时会修改trx_id为70，同时生成一个undo log，而且关键是事务B此时他还提交了，也就是说此时事务B已经结束了，如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111608133.png alt></p><p>这个时候大家思考一个问题，ReadView中的m_ids此时还会是60和70吗？</p><p>那必然是的，因为ReadView一旦生成了就不会改变了，这个时候虽然事务B已经结束了，但是事务A的ReadView里，还是会有60和70两个事务id。</p><p>他的意思其实就是，在你事务A开启查询的时候，事务B当时是在运行的，就是这个意思。</p><p>那么好，接着此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id是70了，70一方面是在ReadView的min_trx_id和max_trx_id的范围区间的，同时还在m_ids列表中</p><p>这说明什么？</p><p>说明起码是事务A开启查询的时候，id为70的这个事务B还是在运行的，然后由这个事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的这个值的，因此这个时候继续顺着指针往历史版本链条上去找，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111609998.png alt></p><p>接着事务A顺着指针找到下面一条数据，trx_id为50，是小于ReadView的min_trx_id的，说明在他开启查询之前，就已经提交了这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111609508.png alt></p><p>大家看到这里有什么感想？是不是感觉到这一下子就避免了不可重复读的问题？</p><p>你事务A多次读同一个数据，每次读到的都是一样的值，除非是他自己修改了值，否则读到的一直会一样的值。</p><p>不管别的事务如何修改数据，事务A的ReadView始终是不变的，他基于这个ReadView始终看到的值是一样的！</p><p>接着我们来看看幻读的问题他是如何解决的。假设现在事务A先用select * from x where id>10来查询，此时可能查到的就是一条数据，而且读到的是这条数据的原始值的那个版本，至于原因，上面都解释过了，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111625985.png alt></p><p>现在有一个事务C插入了一条数据，然后提交了，此时如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111625712.png alt></p><p>接着，此时事务A再次查询，此时会发现符合条件的有2条数据，一条是原始值那个数据，一条是事务C插入的那条数据，但是事务C插入的那条数据的trx_id是80，这个80是大于自己的ReadView的max_trx_id的，说明是自己发起查询之后，这个事务才启动的，所以此时这条数据是不能查询的。</p><p>因此事务A本次查询，还是只能查到原始值一条数据，如下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202205/202205111626957.png alt></p><p>所以大家可以看到，在这里，事务A根本不会发生幻读，他根据条件范围查询的时候，每次读到的数据都是一样的，不会读到人家插入进去的数据，这都是依托ReadView机制实现的！</p><h3 id=梳理一下数据库的多事务并发运行的隔离机制>梳理一下数据库的多事务并发运行的隔离机制</h3><p>今天给大家简单梳理一下MySQL中的多事务并发运行的隔离原理，其实这套隔离原理，说白了就是MVCC机制，也就是multi-version concurrent control，就是多版本并发控制机制，专门控制多个事务并发运行的时候，互相之间会如何影响。</p><p>首先我们先要明白，多个事务并发运行的时候，同时读写一个数据，可能会出现脏写、脏读、不可重复读、幻读几个问题</p><p>所谓的脏写，就是两个事务都更新一个数据，结果有一个人回滚了把另外一个人更新的数据也回滚没了。</p><p>脏读，就是一个事务读到了另外一个事务没提交的时候修改的数据，结果另外一个事务回滚了，下次读就读不到了。</p><p>不可重复读，就是多次读一条数据，别的事务老是修改数据值还提交了，多次读到的值不同。</p><p>幻读，就是范围查询，每次查到的数据不同，有时候别的事务插入了新的值，就会读到更多的数据。</p><p>针对这些问题，所以才有RU、RC、RR和串行四个隔离级别</p><p>RU隔离级别，就是可以读到人家没提交的事务修改的数据，只能避免脏写问题；</p><p>RC隔离级别，可以读到人家提交的事务修改过的数据，可以避免脏写和脏读问题。</p><p>RR是不会读到别的已经提交事务修改的数据，可以避免脏读、脏写和不可重复读的问题；</p><p>串行是让事务都串行执行，可以避免所有问题。</p><p>然后MySQL实现MVCC机制的时候，是基于<strong>undo log多版本链条+ReadView机制</strong>来做的，默认的RR隔离级别，就是基于这套机制来实现的，依托这套机制实现了RR级别，除了避免脏写、脏读、不可重复读，还能避免幻读问题。因此一般来说我们都用默认的RR隔离级别就好了</p><p>这就是数据库的隔离机制以及底层的原理，希望大家好好理解，可以复习一下之前的内容，把这套机制理解清楚了，接下来我们就要开始讲解锁机制了。</p><p>锁机制，解决的就是多个事务同时更新一行数据，此时必须要有一个加锁的机制</p></div><footer class=post-footer><div class=post-tags><a href=/tags/mysql>mysql</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021531496.png alt="青丝蘸白雪i - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021532231.png alt="青丝蘸白雪i - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
【转】理解MVCC机制</li><li class=post-copyright-author><strong>本文作者：</strong>
青丝蘸白雪i</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://b.sxz799.fun/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/ title=【转】理解MVCC机制>https://b.sxz799.fun/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/%E6%8A%80%E5%B7%A7/2022-08-13-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/ rel=next title=记录一个集合相关算法的实现代码><i class="fa fa-chevron-left"></i> 记录一个集合相关算法的实现代码</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-sql%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%844%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/ rel=prev title=【转】SQL标准中对事务的4个隔离级别>【转】SQL标准中对事务的4个隔离级别
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>青丝蘸白雪i</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.113.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":null,"repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://b.sxz799.fun/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":true,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://waline.sxz799.fun/","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql笔记 on 青丝蘸白雪i</title><link>https://blog.sxz799.xyz/categories/mysql%E7%AC%94%E8%AE%B0/</link><description>Recent content in mysql笔记 on 青丝蘸白雪i</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 11 May 2022 16:33:42 +0000</lastBuildDate><atom:link href="https://blog.sxz799.xyz/categories/mysql%E7%AC%94%E8%AE%B0/rss.xml" rel="self" type="application/rss+xml"/><item><title>【转】理解MVCC机制</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 11 May 2022 16:33:42 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-%E7%90%86%E8%A7%A3mvcc%E6%9C%BA%E5%88%B6/</guid><description>&lt;h3 id="理解mvcc机制的前奏undo-log版本链是个什么东西">理解MVCC机制的前奏：undo log版本链是个什么东西？
&lt;a class="header-anchor" href="#%e7%90%86%e8%a7%a3mvcc%e6%9c%ba%e5%88%b6%e7%9a%84%e5%89%8d%e5%a5%8fundo-log%e7%89%88%e6%9c%ac%e9%93%be%e6%98%af%e4%b8%aa%e4%bb%80%e4%b9%88%e4%b8%9c%e8%a5%bf">&lt;/a>
&lt;/h3>&lt;p>简单来说呢，我们每条数据其实都有两个隐藏字段，一个是trx_id，一个是roll_pointer，这个trx_id就是最近一次更新这条数据的事务id，roll_pointer就是指向你了你更新这个事务之前生成的undo log&lt;/p></description></item><item><title>【转】SQL标准中对事务的4个隔离级别</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-sql%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%844%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link><pubDate>Wed, 11 May 2022 16:32:56 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-11-sql%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%844%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid><description>&lt;h3 id="sql标准中对事务的4个隔离级别">SQL标准中对事务的4个隔离级别
&lt;a class="header-anchor" href="#sql%e6%a0%87%e5%87%86%e4%b8%ad%e5%af%b9%e4%ba%8b%e5%8a%a1%e7%9a%844%e4%b8%aa%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab">&lt;/a>
&lt;/h3>&lt;p>这4种级别包括了：&lt;/p></description></item><item><title>【转】什么是脏写、脏读、不可重复读和幻读？</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-10-%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E5%86%99%E8%84%8F%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB/</link><pubDate>Tue, 10 May 2022 14:28:52 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-10-%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E5%86%99%E8%84%8F%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB/</guid><description>&lt;h3 id="多个事务并发执行时候的另外两种问题一个是不可重复读一个是幻读">多个事务并发执行时候的另外两种问题：一个是不可重复读，一个是幻读
&lt;a class="header-anchor" href="#%e5%a4%9a%e4%b8%aa%e4%ba%8b%e5%8a%a1%e5%b9%b6%e5%8f%91%e6%89%a7%e8%a1%8c%e6%97%b6%e5%80%99%e7%9a%84%e5%8f%a6%e5%a4%96%e4%b8%a4%e7%a7%8d%e9%97%ae%e9%a2%98%e4%b8%80%e4%b8%aa%e6%98%af%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e4%b8%80%e4%b8%aa%e6%98%af%e5%b9%bb%e8%af%bb">&lt;/a>
&lt;/h3>&lt;p>多个事务并发执行时候，对MySQL的缓存页里的同一行数据同时进行更新或者查询的时候，可能发生的&lt;strong>脏写和脏读&lt;/strong>的问题&lt;/p></description></item><item><title>【转】重新回顾redo日志对于事务提交后，数据绝对不会丢失的意义 1</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BEredo%E6%97%A5%E5%BF%97%E5%AF%B9%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%84%8F%E4%B9%89-1/</link><pubDate>Mon, 09 May 2022 16:44:55 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BEredo%E6%97%A5%E5%BF%97%E5%AF%B9%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%84%8F%E4%B9%89-1/</guid><description>&lt;p>在更新完Buffer Pool中的缓存页之后，必须要写一条redo log，这样才能记录下来我们对数据库做的修改。
redo log可以保证我们事务提交之后，如果事务中的增删改SQL语句更新的缓存页还没刷到磁盘上去，此时MySQL宕机了，那么MySQL重启过后，就可以把redo log重做一遍，恢复出来事务当时更新的缓存页，然后再把缓存页刷到磁盘就可以了&lt;/p></description></item><item><title>【转】重新回顾redo日志对于事务提交后，数据绝对不会丢失的意义 2</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BEredo%E6%97%A5%E5%BF%97%E5%AF%B9%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%84%8F%E4%B9%89-2/</link><pubDate>Mon, 09 May 2022 16:44:55 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BEredo%E6%97%A5%E5%BF%97%E5%AF%B9%E4%BA%8E%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%84%8F%E4%B9%89-2/</guid><description>&lt;h3 id="如果事务执行到一半要回滚怎么办再探undo-log回滚日志原理">如果事务执行到一半要回滚怎么办？再探undo log回滚日志原理！
&lt;a class="header-anchor" href="#%e5%a6%82%e6%9e%9c%e4%ba%8b%e5%8a%a1%e6%89%a7%e8%a1%8c%e5%88%b0%e4%b8%80%e5%8d%8a%e8%a6%81%e5%9b%9e%e6%bb%9a%e6%80%8e%e4%b9%88%e5%8a%9e%e5%86%8d%e6%8e%a2undo-log%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h3>&lt;p>redo log都是先进入redo log buffer中的一个block，然后事务提交的时候就会刷入磁盘文件里去。&lt;/p>
&lt;p>这样万一要是你提交事务了，结果事务修改的缓存页还没来得及刷入磁盘上的数据文件，此时你MySQL关闭了或者是宕机了，那么buffer pool里被事务修改过的数据就全部都丢失了！&lt;/p></description></item><item><title>【转】如何解决经典的Too many connections故障？背后原理是什么</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BB%8F%E5%85%B8%E7%9A%84too-many-connections%E6%95%85%E9%9A%9C%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 09 May 2022 14:49:06 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BB%8F%E5%85%B8%E7%9A%84too-many-connections%E6%95%85%E9%9A%9C%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>&lt;p>其实核心就是一行命令：&lt;/p></description></item><item><title>【转】一个真实的生产优化案例</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%94%9F%E4%BA%A7%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 09 May 2022 14:49:06 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%94%9F%E4%BA%A7%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/</guid><description>&lt;h3 id="mysql数据库的日志顺序读写以及数据文件随机读写的原理">MySQL数据库的日志顺序读写以及数据文件随机读写的原理
&lt;a class="header-anchor" href="#mysql%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%97%a5%e5%bf%97%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%86%99%e4%bb%a5%e5%8f%8a%e6%95%b0%e6%8d%ae%e6%96%87%e4%bb%b6%e9%9a%8f%e6%9c%ba%e8%af%bb%e5%86%99%e7%9a%84%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h3>&lt;p>先给大家剖析一下MySQL在实际工作时候的两种数据读写机制，一种是对redo log、binlog这种日志进行的磁盘顺序读写，一种是对表空间的磁盘文件里的数据页进行的磁盘随机读写。
简单来说，MySQL在工作的时候，尤其是执行增删改操作的时候，肯定会先从表空间的磁盘文件里读取数据页出来，这个过程其实就是典型的磁盘随机读操作&lt;/p></description></item><item><title>【转】MySQL物理数据模型2</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-mysql%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B2/</link><pubDate>Mon, 09 May 2022 13:38:15 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-mysql%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B2/</guid><description>&lt;h3 id="磁盘上的一行数据到底如何读取出来的">磁盘上的一行数据到底如何读取出来的？
&lt;a class="header-anchor" href="#%e7%a3%81%e7%9b%98%e4%b8%8a%e7%9a%84%e4%b8%80%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%88%b0%e5%ba%95%e5%a6%82%e4%bd%95%e8%af%bb%e5%8f%96%e5%87%ba%e6%9d%a5%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>我们结合上面的磁盘上的数据存储格式来思考一下，一行数据到底是如何读取出来的呢？&lt;/p>
&lt;p>再看上面的磁盘数据存储格式：&lt;/p>
&lt;p>0x09 0x04 00000101 头信息 column1=value1 column2=value2 &amp;hellip; columnN=valueN&lt;/p>
&lt;p>首先他必然要把变长字段长度列表和NULL值列表读取出来，通过综合分析一下，就知道有几个变长字段，哪几个变长字段是NULL，因为NULL值列表里谁是NULL谁不是NULL都一清二楚。&lt;/p></description></item><item><title>【转】MySQL物理数据模型</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-mysql%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B1/</link><pubDate>Mon, 09 May 2022 10:25:56 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-05-09-mysql%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B1/</guid><description>&lt;h3 id="为什么不能直接更新磁盘上的数据">为什么不能直接更新磁盘上的数据？
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e7%9b%b4%e6%8e%a5%e6%9b%b4%e6%96%b0%e7%a3%81%e7%9b%98%e4%b8%8a%e7%9a%84%e6%95%b0%e6%8d%ae">&lt;/a>
&lt;/h3>&lt;p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据，虽然技术上是可以做到的，但是那必然导致执行请求的性能极差。
因为磁盘随机读写的性能是最差的，所以直接更新磁盘文件，必然导致我们的数据库完全无法抗下任何一点点稍微高并发一点的场景。&lt;/p></description></item><item><title>【转】LRU算法优化和性能优化</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-18-lru%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 18 Apr 2022 14:56:10 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-18-lru%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>&lt;h3 id="mysql的预读机制">MYSQL的预读机制
&lt;a class="header-anchor" href="#mysql%e7%9a%84%e9%a2%84%e8%af%bb%e6%9c%ba%e5%88%b6">&lt;/a>
&lt;/h3>&lt;p>MySQL设计了一个预读机制，要把相邻的一些数据页一次性读入到Buffer Pool缓存里去&lt;/p></description></item><item><title>【转】Buffer Pool的内存数据结构</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-18-buffer-pool%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 18 Apr 2022 13:11:03 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-18-buffer-pool%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h3 id="buffer-pool">Buffer Pool
&lt;a class="header-anchor" href="#buffer-pool">&lt;/a>
&lt;/h3>&lt;p>Buffer Pool本质其实就是数据库的一个内存组件，可以理解为他就是一片内存数据结构.
Buffer Pool默认情况下是128MB&lt;/p></description></item><item><title>【转】InnoDB引擎更新数据过程</title><link>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-13-innodb%E5%BC%95%E6%93%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/</link><pubDate>Wed, 13 Apr 2022 15:04:31 +0000</pubDate><guid>https://blog.sxz799.xyz/posts/mysql%E7%AC%94%E8%AE%B0/2022-04-13-innodb%E5%BC%95%E6%93%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/</guid><description>&lt;p>&lt;img src="https://blog.sxz799.xyz/imgs/img-lazy-loading.gif" data-src="https://gh.sxz799.online/https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202204/202204131448504.png" alt="" />&lt;/p></description></item></channel></rss>
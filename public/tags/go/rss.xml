<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on 青丝蘸白雪i</title><link>https://b.sxz799.fun/tags/go/</link><description>Recent content in go on 青丝蘸白雪i</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 10 Jan 2023 15:31:07 +0000</lastBuildDate><atom:link href="https://b.sxz799.fun/tags/go/rss.xml" rel="self" type="application/rss+xml"/><item><title>让Gin-Vue-Admin的表单支持图片</title><link>https://b.sxz799.fun/posts/golang/2023-01-10-%E8%AE%A9gin-vue-admin%E7%9A%84%E8%A1%A8%E5%8D%95%E6%94%AF%E6%8C%81%E5%9B%BE%E7%89%87/</link><pubDate>Tue, 10 Jan 2023 15:31:07 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang/2023-01-10-%E8%AE%A9gin-vue-admin%E7%9A%84%E8%A1%A8%E5%8D%95%E6%94%AF%E6%8C%81%E5%9B%BE%E7%89%87/</guid><description>&lt;p>在学习
&lt;a href="https://www.gin-vue-admin.com/" title="gin-vue-admin" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
gin-vue-admin
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>时发现生成代码时并不支持选择表单输入类型，都是默认的输入框或者下拉框，这样在传图片或附件是就需要手动修改前端来实现此功能。&lt;/p></description></item><item><title>让Gin-Vue-Admin的字典值支持字符串</title><link>https://b.sxz799.fun/posts/golang/2023-01-09-%E8%AE%A9gin-vue-admin%E7%9A%84%E5%AD%97%E5%85%B8%E5%80%BC%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Mon, 09 Jan 2023 19:29:57 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang/2023-01-09-%E8%AE%A9gin-vue-admin%E7%9A%84%E5%AD%97%E5%85%B8%E5%80%BC%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>&lt;p>最近在学习
&lt;a href="https://www.gin-vue-admin.com/" title="gin-vue-admin" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
gin-vue-admin
&lt;i class="fa fa-external-link-alt">&lt;/i>
&lt;/a>开发平台，发现在配置字典时，字典值只能使用int，不能使用string，这样就会导致后期做报表开发时，查看数据库内容时容易摸不到头脑，所以准备改一下源码，使其字典值支持string！&lt;/p></description></item><item><title>Golang中函数返回值注意点</title><link>https://b.sxz799.fun/posts/golang/2022-12-09-golang%E4%B8%AD%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%B3%A8%E6%84%8F%E7%82%B9/</link><pubDate>Fri, 09 Dec 2022 16:20:32 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang/2022-12-09-golang%E4%B8%AD%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%B3%A8%E6%84%8F%E7%82%B9/</guid><description>&lt;p>Go语言函数返回值又两种方法，如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">GoReturn1&lt;/span>() &lt;span style="color:#ff7b72">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#ff7b72;font-weight:bold">:=&lt;/span> &lt;span style="color:#a5d6ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff7b72">return&lt;/span> a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">GoReturn2&lt;/span>() (a &lt;span style="color:#ff7b72">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a = &lt;span style="color:#a5d6ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff7b72">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#d2a8ff;font-weight:bold">Println&lt;/span>(&lt;span style="color:#a5d6ff">&amp;#34;返回值1：&amp;#34;&lt;/span>, &lt;span style="color:#d2a8ff;font-weight:bold">GoReturn1&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#d2a8ff;font-weight:bold">Println&lt;/span>(&lt;span style="color:#a5d6ff">&amp;#34;返回值2：&amp;#34;&lt;/span>, &lt;span style="color:#d2a8ff;font-weight:bold">GoReturn2&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Golang泛型学习笔记</title><link>https://b.sxz799.fun/posts/golang/2022-12-09-golang%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 09 Dec 2022 10:49:28 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang/2022-12-09-golang%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="什么是泛型">什么是泛型？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%9b%e5%9e%8b">&lt;/a>
&lt;/h2>&lt;p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。&lt;/p></description></item><item><title>Go语言实现RPC跨平台服务</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-03-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0rpc%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1/</link><pubDate>Sat, 03 Sep 2022 20:08:11 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-03-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0rpc%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1/</guid><description>&lt;h3 id="什么是rpc-服务">什么是RPC 服务
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afrpc-%e6%9c%8d%e5%8a%a1">&lt;/a>
&lt;/h3>&lt;p>RPC，也就是&lt;strong>远程过程调用&lt;/strong>，是分布式系统中不同节点调用的方式（进程间通信），属于 C/S 模式。RPC 由客户端发起，调用服务端的方法进行通信，然后服务端把结果返回给客户端。&lt;/p>
&lt;p>RPC的核心有两个：&lt;strong>通信协议&lt;/strong>和&lt;strong>序列化&lt;/strong>。在 HTTP 2 之前，一般采用自定义 TCP 协议的方式进行通信，HTTP 2 出来后，也有采用该协议的，比如流行的gRPC。&lt;/p>
&lt;p>序列化和反序列化是&lt;strong>一种把传输内容编码和解码&lt;/strong>的方式，常见的编解码方式有 JSON、Protobuf 等。&lt;/p></description></item><item><title>Go语言RESTfulAPI服务</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-03-%E8%BD%ACgo%E8%AF%AD%E8%A8%80restful-api-%E6%9C%8D%E5%8A%A1/</link><pubDate>Sat, 03 Sep 2022 15:28:43 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-03-%E8%BD%ACgo%E8%AF%AD%E8%A8%80restful-api-%E6%9C%8D%E5%8A%A1/</guid><description>&lt;p>使用G语言编写 RESTful API 和 RPC 服务。在实际开发项目中，编写的这些服务可以被其他服务使用，这样就组成了微服务的架构；也可以被前端调用，这样就可以前后端分离。&lt;/p></description></item><item><title>Go语言模块化管理与协作开发</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-01-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91/</link><pubDate>Thu, 01 Sep 2022 21:55:07 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-09-01-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91/</guid><description>&lt;p>任何业务，都是从简单向复杂演进的。而在业务演进的过程中，技术是从单体向多模块、多服务演进的。技术的这种演进方式的核心目的是复用代码、提高效率。&lt;/p></description></item><item><title>Go语言代码检查和优化</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-30-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%92%8C%E4%BC%98%E5%8C%96/</link><pubDate>Tue, 30 Aug 2022 20:40:16 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-30-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%92%8C%E4%BC%98%E5%8C%96/</guid><description>&lt;h2 id="代码规范检查">代码规范检查
&lt;a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e8%a7%84%e8%8c%83%e6%a3%80%e6%9f%a5">&lt;/a>
&lt;/h2>&lt;h3 id="什么是代码规范检查">什么是代码规范检查
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%bb%a3%e7%a0%81%e8%a7%84%e8%8c%83%e6%a3%80%e6%9f%a5">&lt;/a>
&lt;/h3>&lt;p>代码规范检查，顾名思义，是从 Go 语言层面出发，依据 Go 语言的规范，对你写的代码进行的&lt;strong>静态扫描检查&lt;/strong>，这种检查和你的业务无关。&lt;/p>
&lt;p>比如你定义了个常量，从未使用过，虽然对代码运行并没有造成什么影响，但是这个常量是可以删除的，代码如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">const&lt;/span> name = &lt;span style="color:#a5d6ff">&amp;#34;Golang&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go语言单元测试</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-29-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 29 Aug 2022 20:56:10 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-29-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>&lt;h2 id="单元测试">单元测试
&lt;a class="header-anchor" href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">&lt;/a>
&lt;/h2>&lt;h3 id="什么是单元测试">什么是单元测试
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">&lt;/a>
&lt;/h3>&lt;p>顾名思义，单元测试强调的是对单元进行测试。在开发中，一个单元可以是&lt;strong>一个函数&lt;/strong>、&lt;strong>一个模块&lt;/strong>等。一般情况下，你要测试的单元应该是一个完整的&lt;strong>最小单元&lt;/strong>，比如 Go 语言的函数。这样的话，当每个最小单元都被验证通过，那么整个模块、甚至整个程序就都可以被验证通过。
单元测试由开发者自己编写，也就是谁改动了代码，谁就要编写相应的单元测试代码以验证本次改动的正确性。&lt;/p></description></item><item><title>Go语言中的Slice</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-29-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84slice/</link><pubDate>Mon, 29 Aug 2022 09:50:33 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-29-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84slice/</guid><description>&lt;h3 id="数组">数组
&lt;a class="header-anchor" href="#%e6%95%b0%e7%bb%84">&lt;/a>
&lt;/h3>&lt;p>几乎所有的编程语言里都存在数组，Go 也不例外。那么为什么 Go 语言除了数组之外又设计了 slice 呢？要想解答这个问题，先来了解数组的局限性。&lt;/p>
&lt;p>在下面的示例中，a1、a2 是两个定义好的数组，但是它们的类型不一样。变量 a1 的类型是 [1]string，变量 a2 的类型是 [2]string，也就是说数组的大小属于数组类型的一部分，只有数组内部元素类型和大小一致时，这两个数组才是同一类型。&lt;/p></description></item><item><title>Go语言又爱又恨的unsafe</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-28-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%8F%88%E7%88%B1%E5%8F%88%E6%81%A8%E7%9A%84unsafe/</link><pubDate>Sun, 28 Aug 2022 22:04:55 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-28-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%8F%88%E7%88%B1%E5%8F%88%E6%81%A8%E7%9A%84unsafe/</guid><description>&lt;p>顾名思义，unsafe 是不安全的。Go 将其定义为这个包名，也是为了让我们尽可能地不使用它。不过虽然不安全，它也有优势，那就是可以绕过 Go 的内存安全机制，直接对内存进行读写。所以有时候出于性能需要，还是会冒险使用它来对内存进行操作。&lt;/p></description></item><item><title>Go语言字符串和结构体之间转换</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 27 Aug 2022 22:58:07 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/</guid><description>&lt;p>在web应用调用 API 的时候，需要把 API 返回的 JSON 字符串转换为 struct 结构体，便于操作。那么一个 JSON 字符串是如何转换为 struct 结构体的呢？这就需要用到反射的知识，今天学习基于字符串和结构体之间的转换，一步步地揭开 Go 语言运行时反射的面纱。&lt;/p></description></item><item><title>Go语言中make和new的区别</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-26-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Fri, 26 Aug 2022 13:55:59 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-26-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>&lt;p>程序的运行都需要内存，比如像变量的创建、函数的调用、数据的计算等。所以在需要内存的时候就要申请内存，进行内存分配。在 C/C++ 这类语言中，内存是由开发者自己管理的，需要主动申请和释放，而在 Go 语言中则是由该语言自己管理的，开发者不用做太多干涉，只需要声明变量，Go 语言就会根据变量的类型自动分配相应的内存。&lt;/p></description></item><item><title>Go语言值,引用,指针之间的区别</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-25-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%80%BC%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Thu, 25 Aug 2022 21:45:06 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-25-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%80%BC%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>&lt;h2 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h2>&lt;p>先看一段代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">type&lt;/span> address &lt;span style="color:#ff7b72">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> province &lt;span style="color:#ff7b72">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> city &lt;span style="color:#ff7b72">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> (addr address) &lt;span style="color:#d2a8ff;font-weight:bold">String&lt;/span>() &lt;span style="color:#ff7b72">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff7b72">return&lt;/span> fmt.&lt;span style="color:#d2a8ff;font-weight:bold">Sprintf&lt;/span>(&lt;span style="color:#a5d6ff">&amp;#34;the addr is %s%s&amp;#34;&lt;/span>, addr.province, addr.city)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add &lt;span style="color:#ff7b72;font-weight:bold">:=&lt;/span> address{province: &lt;span style="color:#a5d6ff">&amp;#34;山东省&amp;#34;&lt;/span>, city: &lt;span style="color:#a5d6ff">&amp;#34;济南市&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d2a8ff;font-weight:bold">printString&lt;/span>(add)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d2a8ff;font-weight:bold">printString&lt;/span>(&lt;span style="color:#ff7b72;font-weight:bold">&amp;amp;&lt;/span>add)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">printString&lt;/span>(s fmt.Stringer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#d2a8ff;font-weight:bold">Println&lt;/span>(s.&lt;span style="color:#d2a8ff;font-weight:bold">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f85149">运行结果：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>the addr is &lt;span style="color:#f85149">山东省济南市&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>the addr is &lt;span style="color:#f85149">山东省济南市&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go语言指针学习</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-24-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 24 Aug 2022 21:28:24 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-24-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h2 id="什么是指针">什么是指针
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%8c%87%e9%92%88">&lt;/a>
&lt;/h2>&lt;p>程序运行时的数据是存放在内存中的，而内存会被抽象为一系列具有连续编号的存储空间，那么每一个存储在内存中的数据都会有一个编号，这个编号就是内存地址。有了这个内存地址就可以找到这个内存中存储的数据，而内存地址可以被赋值给一个指针。&lt;/p></description></item><item><title>Go语言常见的高效并发模式</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-18-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 18 Aug 2022 10:16:25 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-18-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>如何用 goroutine、channel、sync包 这些基础元素组成并发模式，更好地编写并发程序。&lt;/p></description></item><item><title>Go语言Context学习笔记</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-16-%E8%BD%ACgo%E8%AF%AD%E8%A8%80context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 16 Aug 2022 16:16:07 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-16-%E8%BD%ACgo%E8%AF%AD%E8%A8%80context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>&lt;h3 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h3>&lt;p>之前学习了怎么在所有的协程运行结束后让程序停止。这次学一下怎么让运行中的协程停止。比如我们开了1个协程去监控一个程序，如果我们手动取消监控就要让协程主动停止任务，该怎么实现呢？用 select+channel 做检测！&lt;/p></description></item><item><title>Go语言中使用sync包控制并发</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 15 Aug 2022 20:41:12 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/</guid><description>&lt;h3 id="syncmutex-和-syncrwmutex">sync.Mutex 和 sync.RWMutex
&lt;a class="header-anchor" href="#syncmutex-%e5%92%8c-syncrwmutex">&lt;/a>
&lt;/h3>&lt;p>如果同一块内存被多个 goroutine 同时访问，就会产生不知道谁先访问也无法预料最后结果的情况。这就是资源竞争，这块内存可以称为共享的资源。例如下面的代码&lt;/p></description></item><item><title>Go语言使用channel进行goroutine通信</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8channel%E8%BF%9B%E8%A1%8Cgoroutine%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 15 Aug 2022 10:38:35 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8channel%E8%BF%9B%E8%A1%8Cgoroutine%E9%80%9A%E4%BF%A1/</guid><description>&lt;h4 id="声明channel">声明channel
&lt;a class="header-anchor" href="#%e5%a3%b0%e6%98%8echannel">&lt;/a>
&lt;/h4>&lt;p>channel是go语言中的一种数据类型，也叫通道
声明方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>ch&lt;span style="color:#ff7b72;font-weight:bold">:=&lt;/span>make(&lt;span style="color:#ff7b72">chan&lt;/span> &lt;span style="color:#ff7b72">string&lt;/span>, n)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>ch : channel的变量名&lt;/li>
&lt;li>chan : 声明channel的关键字&lt;/li>
&lt;li>string : channel中存储额数据类型&lt;/li>
&lt;li>n: 缓冲长度(不填时代表无缓冲)&lt;/li>
&lt;/ul></description></item><item><title>Go语言错误处理笔记</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 14 Aug 2022 21:54:46 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">type&lt;/span> &lt;span style="color:#ff7b72">error&lt;/span> &lt;span style="color:#ff7b72">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d2a8ff;font-weight:bold">Error&lt;/span>() &lt;span style="color:#ff7b72">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go语言接口学习笔记</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 14 Aug 2022 19:32:34 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>&lt;h3 id="一接口的定义">一、接口的定义
&lt;a class="header-anchor" href="#%e4%b8%80%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%ae%9a%e4%b9%89">&lt;/a>
&lt;/h3>&lt;p>接口是和调用方的一种约定 是一个高度抽象的类型 不同和具体的实现细节绑定在一起&lt;/p></description></item><item><title>Go语言中函数和方法的区别</title><link>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sun, 14 Aug 2022 16:26:28 +0000</pubDate><guid>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-14-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>&lt;h2 id="一函数">一、函数
&lt;a class="header-anchor" href="#%e4%b8%80%e5%87%bd%e6%95%b0">&lt;/a>
&lt;/h2>&lt;h3 id="1举个">1.举个🌰
&lt;a class="header-anchor" href="#1%e4%b8%be%e4%b8%aa">&lt;/a>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:1;-o-tab-size:1;tab-size:1;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff7b72">func&lt;/span> &lt;span style="color:#d2a8ff;font-weight:bold">sum&lt;/span>(a,b &lt;span style="color:#ff7b72">int&lt;/span>) &lt;span style="color:#ff7b72">int&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff7b72">return&lt;/span> a&lt;span style="color:#ff7b72;font-weight:bold">+&lt;/span>b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>
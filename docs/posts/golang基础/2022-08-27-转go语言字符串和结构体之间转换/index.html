<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><link rel=icon type=image/x-icon href=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><meta itemprop=name content="Go语言字符串和结构体之间转换"><meta itemprop=description content="好记性不如烂笔头..."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG"><meta itemprop=keywords content="go"><meta property="og:type" content="article"><meta property="og:title" content="Go语言字符串和结构体之间转换"><meta property="og:description" content="好记性不如烂笔头..."><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/"><meta property="og:site_name" content="青丝蘸白雪i"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="青丝蘸白雪i"><meta property="article:published_time" content="2022-08-27 22:58:07 +0000 UTC"><meta property="article:modified_time" content="2022-08-27 22:58:07 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.df155ae781e4bac8f4cf613fdb817af646eb609c549c9914d3e5371f95fcffa8.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:""}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2","permalink":"https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/","title":"Go语言字符串和结构体之间转换","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Go语言字符串和结构体之间转换 - 青丝蘸白雪i</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>青丝蘸白雪i</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>79</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#反射是什么>反射是什么？</a></li><li><a href=#reflectvalue-和-reflecttype>reflect.Value 和 reflect.Type</a><ul><li><a href=#reflectvalue>reflect.Value</a><ul><li><a href=#获取原始类型>获取原始类型</a></li><li><a href=#修改对应的值>修改对应的值</a></li><li><a href=#获取对应的底层类型>获取对应的底层类型</a></li></ul></li><li><a href=#reflecttype>reflect.Type</a><ul><li><a href=#接口定义>接口定义</a></li><li><a href=#遍历结构体的字段和方法>遍历结构体的字段和方法</a></li><li><a href=#是否实现某接口>是否实现某接口</a></li></ul></li><li><a href=#字符串和结构体互转>字符串和结构体互转</a><ul><li><a href=#实现-struct-转-json>实现 Struct 转 JSON</a></li></ul></li></ul></li><li><a href=#反射定律>反射定律</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=青丝蘸白雪i src=/imgs/img-lazy-loading.gif data-src=https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG><p class=site-author-name itemprop=name>青丝蘸白雪i</p><div class=site-description itemprop=description>好记性不如烂笔头...</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>79</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>44</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/sxz799 title="Github → https://github.com/sxz799" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities title="知乎 → https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2019-03-13T21:53:21+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=139637></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=316></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-05-12T19:58:41+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="https://cdn.jsdelivr.net/gh/sxz799/tuchuang-blog/img/202304/IMG_0681.PNG"><meta itemprop=name content="青丝蘸白雪i"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="青丝蘸白雪i"><meta itemprop=description content="好记性不如烂笔头..."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Go语言字符串和结构体之间转换"><meta itemprop=description content="在web应用调用 API 的时候，需要把 API 返回的 JSON 字符串转换为 struct 结构体，便于操作。那么一个 JSON 字符串是如何转换为 struct 结构体的呢？这就需要用到反射的知识，今天学习基于字符串和结构体之间的转换，一步步地揭开 Go 语言运行时反射的面纱。"></span><header class=post-header><h1 class=post-title itemprop="name headline">Go语言字符串和结构体之间转换</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-08-27 22:58:07 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-08-27 22:58:07 +0000 UTC">2022-08-27</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/go%E5%9F%BA%E7%A1%80 itemprop=url rel=index><span itemprop=name>go基础</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>5376</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=评论><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>评论：</span>
<span class=waline-comment-count data-path=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>在web应用调用 API 的时候，需要把 API 返回的 JSON 字符串转换为 struct 结构体，便于操作。那么一个 JSON 字符串是如何转换为 struct 结构体的呢？这就需要用到反射的知识，今天学习基于字符串和结构体之间的转换，一步步地揭开 Go 语言运行时反射的面纱。</p><h2 id=反射是什么>反射是什么？</h2><p>和 Java 语言一样，Go 语言也有运行时反射，这为我们<strong>提供了一种可以在运行时操作任意类型对象的能力</strong>。比如查看一个接口变量的具体类型、看看一个结构体有多少字段、修改某个字段的值等。</p><p>Go 语言是静态编译类语言，比如在定义一个变量的时候，已经知道了它是什么类型，那么为什么还需要反射呢？这是因为有些事情只有在运行时才知道。比如你定义了一个函数，它有一个<strong>interface</strong>{}类型的参数，这也就意味着调用者可以传递任何类型的参数给这个函数。在这种情况下，如果你想知道调用传递的是什么类型的参数，就需要用到反射。如果你想知道一个结构体有哪些字段和方法，也需要反射。
以常用的函数 fmt.Println 为例，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>//src/fmt/print.go
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Println</span>(a <span style=color:#666>...</span><span style=color:#a2f;font-weight:700>interface</span>{}) (n <span style=color:#0b0;font-weight:700>int</span>, err <span style=color:#0b0;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>Fprintln</span>(os.Stdout, a<span style=color:#666>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>fmt.Println 的源代码有一个可变参数，类型为 interface{}，这意味着你可以传递零个或者多个任意类型参数给它，都能被正确打印。</p><h2 id=reflectvalue-和-reflecttype>reflect.Value 和 reflect.Type</h2><p>在 Go 语言的反射定义中，任何接口都由两部分组成：接口的具体类型，以及具体类型对应的值。比如 var i int = 3，因为 interface{} 可以表示任何类型，所以变量 i 可以转为 interface{}。你可以把变量 i 当成一个接口，那么这个变量在 Go 反射中的表示就是 &lt;Value,Type>。其中 Value 为变量的值，即 3，而 Type 为变量的类型，即 int。</p><blockquote><p>小提示：interface{} 是空接口，可以表示任何类型，也就是说你可以把任何类型转换为空接口，它通常用于反射、类型断言，以减少重复代码，简化编程。</p></blockquote><p>在 Go 反射中，标准库为我们提供了两种类型 reflect.Value 和 reflect.Type 来分别表示变量的值和类型，并且提供了两个函数 reflect.ValueOf 和 reflect.TypeOf 分别获取任意对象的 reflect.Value 和 reflect.Type。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	i <span style=color:#666>:=</span> <span style=color:#666>3</span>
</span></span><span style=display:flex><span>	iv <span style=color:#666>:=</span> reflect.<span style=color:#00a000>ValueOf</span>(i)
</span></span><span style=display:flex><span>	it <span style=color:#666>:=</span> reflect.<span style=color:#00a000>TypeOf</span>(i)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;value : &#34;</span>, iv)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;type : &#34;</span>, it)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span>value :  <span style=color:#666>3</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> :  <span style=color:#0b0;font-weight:700>int</span>
</span></span></code></pre></div><p>代码定义了一个 int 类型的变量 i，它的值为 3，然后通过 reflect.ValueOf 和 reflect.TypeOf 函数就可以获得变量 i 对应的 reflect.Value 和 reflect.Type。通过 fmt.Println 函数打印后，可以看到结果，这也可以证明 reflect.Value 表示的是变量的值，reflect.Type 表示的是变量的类型。</p><h3 id=reflectvalue>reflect.Value</h3><p>在 Go 语言中，reflect.Value 被定义为一个 struct 结构体，它的定义如下面的代码所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>// src/reflect/value.go
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> Value <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>   typ <span style=color:#666>*</span>rtype
</span></span><span style=display:flex><span>   ptr unsafe.Pointer
</span></span><span style=display:flex><span>   flag
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>reflect.Value 结构体的字段都是私有的，也就是说，我们只能使用 reflect.Value 的方法。现在看看它有哪些常用方法，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>//针对具体类型的系列方法
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//以下是用于获取对应的值
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Bool
</span></span><span style=display:flex><span>Bytes
</span></span><span style=display:flex><span>Complex
</span></span><span style=display:flex><span>Float
</span></span><span style=display:flex><span>Int
</span></span><span style=display:flex><span>String
</span></span><span style=display:flex><span>Uint
</span></span><span style=display:flex><span>CanSet <span style=color:#080;font-style:italic>//是否可以修改对应的值
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span>以下是用于修改对应的值</span>
</span></span><span style=display:flex><span>Set
</span></span><span style=display:flex><span>SetBool
</span></span><span style=display:flex><span>SetBytes
</span></span><span style=display:flex><span>SetComplex
</span></span><span style=display:flex><span>SetFloat
</span></span><span style=display:flex><span>SetInt
</span></span><span style=display:flex><span>SetString
</span></span><span style=display:flex><span>Elem <span style=color:#080;font-style:italic>//获取指针指向的值，一般用于修改对应的值
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//以下Field系列方法用于获取struct类型中的字段
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Field
</span></span><span style=display:flex><span>FieldByIndex
</span></span><span style=display:flex><span>FieldByName
</span></span><span style=display:flex><span>FieldByNameFunc
</span></span><span style=display:flex><span>Interface <span style=color:#080;font-style:italic>//获取对应的原始类型
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>IsNil <span style=color:#080;font-style:italic>//值是否为nil
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>IsZero <span style=color:#080;font-style:italic>//值是否是零值
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Kind <span style=color:#080;font-style:italic>//获取对应的类型类别，比如Array、Slice、Map等
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//获取对应的方法
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Method
</span></span><span style=display:flex><span>MethodByName
</span></span><span style=display:flex><span>NumField <span style=color:#080;font-style:italic>//获取struct类型中字段的数量
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>NumMethod<span style=color:#080;font-style:italic>//类型上方法集的数量
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>Type<span style=color:#080;font-style:italic>//获取对应的reflect.Type
</span></span></span></code></pre></div><p>看着比较多，其实就三类：</p><ul><li>一类用于获取和修改对应的值；</li><li>一类和 struct 类型的字段有关，用于获取对应的字段；</li><li>一类和类型上的方法集有关，用于获取对应的方法。</li></ul><h4 id=获取原始类型>获取原始类型</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   i<span style=color:#666>:=</span><span style=color:#666>3</span>
</span></span><span style=display:flex><span>   iv<span style=color:#666>:=</span>reflect.<span style=color:#00a000>ValueOf</span>(i)
</span></span><span style=display:flex><span>   i1<span style=color:#666>:=</span>iv.<span style=color:#00a000>Interface</span>().(<span style=color:#0b0;font-weight:700>int</span>)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(i1)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span><span style=color:#666>3</span>
</span></span></code></pre></div><h4 id=修改对应的值>修改对应的值</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   i<span style=color:#666>:=</span><span style=color:#666>3</span>
</span></span><span style=display:flex><span>   ipv<span style=color:#666>:=</span>reflect.<span style=color:#00a000>ValueOf</span>(<span style=color:#666>&amp;</span>i)
</span></span><span style=display:flex><span>   ipv.<span style=color:#00a000>Elem</span>().<span style=color:#00a000>SetInt</span>(<span style=color:#666>4</span>)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(i)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span><span style=color:#666>4</span>
</span></span></code></pre></div><p>这样就通过反射修改了一个变量。因为 reflect.ValueOf 函数返回的是一份值的拷贝，所以我们要传入变量的指针才可以。 因为传递的是一个指针，所以需要调用 Elem 方法找到这个指针指向的值，这样才能修改。 最后我们就可以使用 SetInt 方法修改值了。</p><p>要修改一个变量的值，有几个关键点：传递指针（可寻址），通过 Elem 方法获取指向的值，才可以保证值可以被修改，reflect.Value 为我们提供了 CanSet 方法判断是否可以修改该变量。</p><p>那么如何修改 struct 结构体字段的值呢？参考变量的修改方式，可总结出以下步骤：</p><ol><li><p>传递一个 struct 结构体的指针，获取对应的 reflect.Value；</p></li><li><p>通过 Elem 方法获取指针指向的值；</p></li><li><p>通过 Field 方法获取要修改的字段；</p></li><li><p>通过 Set 系列方法修改成对应的值。</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	p <span style=color:#666>:=</span> person{Name: <span style=color:#b44>&#34;张三&#34;</span>, Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>	ppv <span style=color:#666>:=</span> reflect.<span style=color:#00a000>ValueOf</span>(<span style=color:#666>&amp;</span>p)
</span></span><span style=display:flex><span>	ppv.<span style=color:#00a000>Elem</span>().<span style=color:#00a000>Field</span>(<span style=color:#666>0</span>).<span style=color:#00a000>SetString</span>(<span style=color:#b44>&#34;李四&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(p)
</span></span><span style=display:flex><span>	ppv.<span style=color:#00a000>Elem</span>().<span style=color:#00a000>FieldByName</span>(<span style=color:#b44>&#34;Name&#34;</span>).<span style=color:#00a000>SetString</span>(<span style=color:#b44>&#34;王五&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(p)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> person <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Name <span style=color:#0b0;font-weight:700>string</span>
</span></span><span style=display:flex><span>	Age  <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span>{<span>李四</span> <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>{<span>王五</span> <span style=color:#666>20</span>}
</span></span></code></pre></div><p>最后再来总结一下通过反射修改一个值的规则。</p><p>可被寻址，通俗地讲就是要向 reflect.ValueOf 函数传递一个指针作为参数。</p><ol><li><p>如果要修改 struct 结构体字段值的话，该字段需要是可导出的，而不是私有的，也就是该字段的首字母为大写。</p></li><li><p>记得使用 Elem 方法获得指针指向的值，这样才能调用 Set 系列方法进行修改。</p></li><li><p>记住以上规则，你就可以在程序运行时通过反射修改一个变量或字段的值。</p></li></ol><h4 id=获取对应的底层类型>获取对应的底层类型</h4><p>底层类型是什么意思呢？其实对应的主要是基础类型，比如接口、结构体、指针&mldr;&mldr;因为我们可以通过 type 关键字声明很多新的类型。比如在上面的例子中，变量 p 的实际类型是 person，但是 person 对应的底层类型是 struct 这个结构体类型，而 &amp;p 对应的则是指针类型。我们来通过下面的代码进行验证：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   p<span style=color:#666>:=</span>person{Name: <span style=color:#b44>&#34;张三&#34;</span>,Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>   ppv<span style=color:#666>:=</span>reflect.<span style=color:#00a000>ValueOf</span>(<span style=color:#666>&amp;</span>p)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(ppv.<span style=color:#00a000>Kind</span>())
</span></span><span style=display:flex><span>   pv<span style=color:#666>:=</span>reflect.<span style=color:#00a000>ValueOf</span>(p)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(pv.<span style=color:#00a000>Kind</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span>ptr
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span>
</span></span></code></pre></div><p>Kind 方法返回一个 Kind 类型的值，它是一个常量，有以下可供使用的值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>// src/reflect/type.go
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> Kind <span style=color:#0b0;font-weight:700>uint</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> (
</span></span><span style=display:flex><span>   Invalid Kind = <span style=color:#a2f;font-weight:700>iota</span>
</span></span><span style=display:flex><span>   Bool
</span></span><span style=display:flex><span>   Int
</span></span><span style=display:flex><span>   Int8
</span></span><span style=display:flex><span>   Int16
</span></span><span style=display:flex><span>   Int32
</span></span><span style=display:flex><span>   Int64
</span></span><span style=display:flex><span>   Uint
</span></span><span style=display:flex><span>   Uint8
</span></span><span style=display:flex><span>   Uint16
</span></span><span style=display:flex><span>   Uint32
</span></span><span style=display:flex><span>   Uint64
</span></span><span style=display:flex><span>   Uintptr
</span></span><span style=display:flex><span>   Float32
</span></span><span style=display:flex><span>   Float64
</span></span><span style=display:flex><span>   Complex64
</span></span><span style=display:flex><span>   Complex128
</span></span><span style=display:flex><span>   Array
</span></span><span style=display:flex><span>   Chan
</span></span><span style=display:flex><span>   Func
</span></span><span style=display:flex><span>   Interface
</span></span><span style=display:flex><span>   Map
</span></span><span style=display:flex><span>   Ptr
</span></span><span style=display:flex><span>   Slice
</span></span><span style=display:flex><span>   String
</span></span><span style=display:flex><span>   Struct
</span></span><span style=display:flex><span>   UnsafePointer
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>从以上源代码定义的 Kind 常量列表可以看到，已经包含了 Go 语言的所有底层类型。</p><h3 id=reflecttype>reflect.Type</h3><p>reflect.Value 可以用于与值有关的操作中，而如果是和变量类型本身有关的操作，则最好使用 reflect.Type，比如要获取结构体对应的字段名称或方法。</p><p>要反射获取一个变量的 reflect.Type，可以通过函数 reflect.TypeOf。</p><h4 id=接口定义>接口定义</h4><p>和 reflect.Value 不同，reflect.Type 是一个接口，而不是一个结构体，所以也只能使用它的方法。</p><p>以下是我列出来的 reflect.Type 接口常用的方法。从这个列表来看，大部分都和 reflect.Value 的方法功能相同。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> Type <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#00a000>Implements</span>(u Type) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#00a000>AssignableTo</span>(u Type) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#00a000>ConvertibleTo</span>(u Type) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#00a000>Comparable</span>() <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//以下这些方法和Value结构体的功能相同
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	<span style=color:#00a000>Kind</span>() Kind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#00a000>Method</span>(<span style=color:#0b0;font-weight:700>int</span>) Method
</span></span><span style=display:flex><span>	<span style=color:#00a000>MethodByName</span>(<span style=color:#0b0;font-weight:700>string</span>) (Method, <span style=color:#0b0;font-weight:700>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#00a000>NumMethod</span>() <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span>	<span style=color:#00a000>Elem</span>() Type
</span></span><span style=display:flex><span>	<span style=color:#00a000>Field</span>(i <span style=color:#0b0;font-weight:700>int</span>) StructField
</span></span><span style=display:flex><span>	<span style=color:#00a000>FieldByIndex</span>(index []<span style=color:#0b0;font-weight:700>int</span>) StructField
</span></span><span style=display:flex><span>	<span style=color:#00a000>FieldByName</span>(name <span style=color:#0b0;font-weight:700>string</span>) (StructField, <span style=color:#0b0;font-weight:700>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#00a000>FieldByNameFunc</span>(match <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>bool</span>) (StructField, <span style=color:#0b0;font-weight:700>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#00a000>NumField</span>() <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中几个特有的方法如下：</p><ol><li><p>Implements 方法用于判断是否实现了接口 u；</p></li><li><p>AssignableTo 方法用于判断是否可以赋值给类型 u，其实就是是否可以使用 =，即赋值运算符；</p></li><li><p>ConvertibleTo 方法用于判断是否可以转换成类型 u，其实就是是否可以进行类型转换；</p></li><li><p>Comparable 方法用于判断该类型是否是可比较的，其实就是是否可以使用关系运算符进行比较。</p></li></ol><h4 id=遍历结构体的字段和方法>遍历结构体的字段和方法</h4><p>先给person类型添加一个String方法</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> (p person) <span style=color:#00a000>String</span>() <span style=color:#0b0;font-weight:700>string</span>{
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>return</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;Name is %s,Age is %d&#34;</span>,p.Name,p.Age)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新增一个 String 方法，返回对应的字符串信息，这样 person 这个 struct 结构体也实现了 fmt.Stringer 接口。
可以通过 NumField 方法获取结构体字段的数量，然后使用 for 循环，通过 Field 方法就可以遍历结构体的字段，并打印出字段名称。同理，遍历结构体的方法也是同样的思路，代码也类似，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   p<span style=color:#666>:=</span>person{Name: <span style=color:#b44>&#34;张三&#34;</span>,Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>   pt<span style=color:#666>:=</span>reflect.<span style=color:#00a000>TypeOf</span>(p)
</span></span><span style=display:flex><span>   <span style=color:#080;font-style:italic>//遍历person的字段
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   <span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span><span style=color:#666>0</span>;i&lt;pt.<span style=color:#00a000>NumField</span>();i<span style=color:#666>++</span>{
</span></span><span style=display:flex><span>      fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;字段：&#34;</span>,pt.<span style=color:#00a000>Field</span>(i).Name)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#080;font-style:italic>//遍历person的方法
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   <span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span><span style=color:#666>0</span>;i&lt;pt.<span style=color:#00a000>NumMethod</span>();i<span style=color:#666>++</span>{
</span></span><span style=display:flex><span>      fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;方法：&#34;</span>,pt.<span style=color:#00a000>Method</span>(i).Name)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span><span>字段：</span> Name
</span></span><span style=display:flex><span><span>字段：</span> Age
</span></span><span style=display:flex><span><span>方法：</span> String
</span></span></code></pre></div><blockquote><p>小技巧：你可以通过 FieldByName 方法获取指定的字段，也可以通过 MethodByName 方法获取指定的方法，这在需要获取某个特定的字段或者方法时非常高效，而不是使用遍历。</p></blockquote><h4 id=是否实现某接口>是否实现某接口</h4><p>通过 reflect.Type 还可以判断是否实现了某接口。我还是以 person 结构体为例，判断它是否实现了接口 fmt.Stringer 和 io.Writer，如下面的代码所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   p<span style=color:#666>:=</span>person{Name: <span style=color:#b44>&#34;张三&#34;</span>,Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>   pt<span style=color:#666>:=</span>reflect.<span style=color:#00a000>TypeOf</span>(p)
</span></span><span style=display:flex><span>   stringerType<span style=color:#666>:=</span>reflect.<span style=color:#00a000>TypeOf</span>((<span style=color:#666>*</span>fmt.Stringer)(<span style=color:#a2f;font-weight:700>nil</span>)).<span style=color:#00a000>Elem</span>()
</span></span><span style=display:flex><span>   writerType<span style=color:#666>:=</span>reflect.<span style=color:#00a000>TypeOf</span>((<span style=color:#666>*</span>io.Writer)(<span style=color:#a2f;font-weight:700>nil</span>)).<span style=color:#00a000>Elem</span>()
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;是否实现了fmt.Stringer：&#34;</span>,pt.<span style=color:#00a000>Implements</span>(stringerType))
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;是否实现了io.Writer：&#34;</span>,pt.<span style=color:#00a000>Implements</span>(writerType))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span><span>是否实现了</span>fmt.Stringer<span>：</span> <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span><span>是否实现了</span>io.Writer<span>：</span> <span style=color:#a2f;font-weight:700>false</span>
</span></span></code></pre></div><blockquote><p>小提示：尽可能通过类型断言的方式判断是否实现了某接口，而不是通过反射。</p></blockquote><h3 id=字符串和结构体互转>字符串和结构体互转</h3><p>Go 语言的标准库有一个 json 包，通过它可以把 JSON 字符串转为一个 struct 结构体，也可以把一个 struct 结构体转为一个 json 字符串。如下面的代码所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	p <span style=color:#666>:=</span> person{Name: <span style=color:#b44>&#34;张三&#34;</span>, Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//struct to json
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	jsonB, err <span style=color:#666>:=</span> json.<span style=color:#00a000>Marshal</span>(p)
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#00a000>Println</span>(<span style=color:#a2f>string</span>(jsonB))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//json to struct
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	respJSON <span style=color:#666>:=</span> <span style=color:#b44>&#34;{\&#34;Name\&#34;:\&#34;李四\&#34;,\&#34;Age\&#34;:40}&#34;</span>
</span></span><span style=display:flex><span>	json.<span style=color:#00a000>Unmarshal</span>([]<span style=color:#a2f>byte</span>(respJSON), <span style=color:#666>&amp;</span>p)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(p)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span>{<span style=color:#b44>&#34;Name&#34;</span>:<span style=color:#b44>&#34;张三&#34;</span>,<span style=color:#b44>&#34;Age&#34;</span>:<span style=color:#666>20</span>}
</span></span><span style=display:flex><span>Name is <span>李四</span>,Age is <span style=color:#666>40</span>
</span></span></code></pre></div><p>仔细观察以上打印出的 JSON 字符串，发现 JSON 字符串的 Key 和 struct 结构体的字段名称一样，比如示例中的 Name 和 Age。那么是否可以改变它们呢？比如改成小写的 name 和 age，并且字段的名称还是大写的 Name 和 Age。当然可以，要达到这个目的就需要用到 struct tag 的功能了。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>//修改结构体的定义
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> person <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>   Name <span style=color:#0b0;font-weight:700>string</span> <span style=color:#b44>`json:&#34;name&#34;`</span>
</span></span><span style=display:flex><span>   Age <span style=color:#0b0;font-weight:700>int</span> <span style=color:#b44>`json:&#34;age&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>修改后上面的代码</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	p <span style=color:#666>:=</span> person{Name: <span style=color:#b44>&#34;张三&#34;</span>, Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//struct to json
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	jsonB, err <span style=color:#666>:=</span> json.<span style=color:#00a000>Marshal</span>(p)
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#00a000>Println</span>(<span style=color:#a2f>string</span>(jsonB))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//json to struct
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	respJSON <span style=color:#666>:=</span> <span style=color:#b44>&#34;{\&#34;name\&#34;:\&#34;李四\&#34;,\&#34;Age\&#34;:40}&#34;</span>
</span></span><span style=display:flex><span>	json.<span style=color:#00a000>Unmarshal</span>([]<span style=color:#a2f>byte</span>(respJSON), <span style=color:#666>&amp;</span>p)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(p)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span>{<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;张三&#34;</span>,<span style=color:#b44>&#34;age&#34;</span>:<span style=color:#666>20</span>}
</span></span><span style=display:flex><span>Name is <span>李四</span>,Age is <span style=color:#666>40</span>
</span></span></code></pre></div><p>可以发现输入json已经变成了小写，而且在json转结构体时,字段名和tag都是可以用的.</p><p>struct tag 是整个 JSON 和 struct 互转的关键，这个 tag 就像是我们为 struct 字段起的别名，那么 json 包是如何获得这个 tag 的呢？这就需要反射了。我们来看下面的代码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span><span style=color:#666>0</span>;i&lt;pt.<span style=color:#00a000>NumField</span>();i<span style=color:#666>++</span>{
</span></span><span style=display:flex><span>   sf<span style=color:#666>:=</span>pt.<span style=color:#00a000>Field</span>(i)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;字段%s上,json tag为%s\n&#34;</span>,sf.Name,sf.Tag.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;json&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要想获得字段上的 tag，就要先反射获得对应的字段，我们可以通过 Field 方法做到。该方法返回一个 StructField 结构体，它有一个字段是 Tag，存有字段的所有 tag。示例中要获得 Key 为 json 的 tag，所以只需要调用 sf.Tag.Get(&ldquo;json&rdquo;) 即可。</p><p>结构体的字段可以有多个 tag，用于不同的场景，比如 json 转换、bson 转换、orm 解析等。如果有多个 tag，要使用空格分隔。采用不同的 Key 可以获得不同的 tag，如下面的代码所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> person <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Name <span style=color:#0b0;font-weight:700>string</span> <span style=color:#b44>`json:&#34;name&#34; bson:&#34;b_name&#34;`</span>
</span></span><span style=display:flex><span>	Age  <span style=color:#0b0;font-weight:700>int</span>    <span style=color:#b44>`json:&#34;age&#34; bson:&#34;b_name&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> (p person) <span style=color:#00a000>String</span>() <span style=color:#0b0;font-weight:700>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;Name is %s,Age is %d&#34;</span>, p.Name, p.Age)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	p <span style=color:#666>:=</span> person{Name: <span style=color:#b44>&#34;张三&#34;</span>, Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//struct to json
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	pt <span style=color:#666>:=</span> reflect.<span style=color:#00a000>TypeOf</span>(p)
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//遍历person字段中key为json、bson的tag
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; pt.<span style=color:#00a000>NumField</span>(); i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		sf <span style=color:#666>:=</span> pt.<span style=color:#00a000>Field</span>(i)
</span></span><span style=display:flex><span>		fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;字段%s上,json tag为%s\n&#34;</span>, sf.Name, sf.Tag.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;json&#34;</span>))
</span></span><span style=display:flex><span>		fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;字段%s上,bson tag为%s\n&#34;</span>, sf.Name, sf.Tag.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;bson&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果</span>
</span></span><span style=display:flex><span><span>字段</span>Name<span>上</span>,json tag<span>为</span>name
</span></span><span style=display:flex><span><span>字段</span>Name<span>上</span>,bson tag<span>为</span>b_name
</span></span><span style=display:flex><span><span>字段</span>Age<span>上</span>,json tag<span>为</span>age
</span></span><span style=display:flex><span><span>字段</span>Age<span>上</span>,bson tag<span>为</span>b_name
</span></span></code></pre></div><h4 id=实现-struct-转-json>实现 Struct 转 JSON</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>   p<span style=color:#666>:=</span>person{Name: <span style=color:#b44>&#34;张三&#34;</span>,Age: <span style=color:#666>20</span>}
</span></span><span style=display:flex><span>   pv<span style=color:#666>:=</span>reflect.<span style=color:#00a000>ValueOf</span>(p)
</span></span><span style=display:flex><span>   pt<span style=color:#666>:=</span>reflect.<span style=color:#00a000>TypeOf</span>(p)
</span></span><span style=display:flex><span>   <span style=color:#080;font-style:italic>//自己实现的struct to json
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   jsonBuilder<span style=color:#666>:=</span>strings.Builder{}
</span></span><span style=display:flex><span>   jsonBuilder.<span style=color:#00a000>WriteString</span>(<span style=color:#b44>&#34;{&#34;</span>)
</span></span><span style=display:flex><span>   num<span style=color:#666>:=</span>pt.<span style=color:#00a000>NumField</span>()
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>for</span> i<span style=color:#666>:=</span><span style=color:#666>0</span>;i&lt;num;i<span style=color:#666>++</span>{
</span></span><span style=display:flex><span>      jsonTag<span style=color:#666>:=</span>pt.<span style=color:#00a000>Field</span>(i).Tag.<span style=color:#00a000>Get</span>(<span style=color:#b44>&#34;json&#34;</span>) <span style=color:#080;font-style:italic>//获取json tag
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      jsonBuilder.<span style=color:#00a000>WriteString</span>(<span style=color:#b44>&#34;\&#34;&#34;</span><span style=color:#666>+</span>jsonTag<span style=color:#666>+</span><span style=color:#b44>&#34;\&#34;&#34;</span>)
</span></span><span style=display:flex><span>      jsonBuilder.<span style=color:#00a000>WriteString</span>(<span style=color:#b44>&#34;:&#34;</span>)
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>//获取字段的值
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>      jsonBuilder.<span style=color:#00a000>WriteString</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;\&#34;%v\&#34;&#34;</span>,pv.<span style=color:#00a000>Field</span>(i)))
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span> i&lt;num<span style=color:#666>-</span><span style=color:#666>1</span>{
</span></span><span style=display:flex><span>         jsonBuilder.<span style=color:#00a000>WriteString</span>(<span style=color:#b44>&#34;,&#34;</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   jsonBuilder.<span style=color:#00a000>WriteString</span>(<span style=color:#b44>&#34;}&#34;</span>)
</span></span><span style=display:flex><span>   fmt.<span style=color:#00a000>Println</span>(jsonBuilder.<span style=color:#00a000>String</span>())<span style=color:#080;font-style:italic>//打印json字符串
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>}
</span></span></code></pre></div><p>json 字符串的转换只是 struct tag 的一个应用场景，你完全可以把 struct tag 当成结构体中字段的元数据配置，使用它来做想做的任何事情，比如 orm 映射、xml 转换、生成 swagger 文档等。</p><h2 id=反射定律>反射定律</h2><p>反射是计算机语言中程序检视其自身结构的一种方法，它属于元编程的一种形式。反射灵活、强大，但也存在不安全。它可以绕过编译器的很多静态检查，如果过多使用便会造成混乱。为了帮助开发者更好地理解反射，Go 语言的作者在博客上总结了反射的三大定律。</p><ul><li><p>任何接口值 interface{} 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</p></li><li><p>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的可逆性，通过 reflect.Value 结构体的 Interface 方法获得。</p></li><li><p>要修改反射的对象，该值必须可设置，也就是可寻址，参考修改变量的值的内容理解。</p></li></ul><blockquote><p>小提示：任何类型的变量都可以转换为空接口 intferface{}，所以第 1 条定律中函数 reflect.ValueOf 和 reflect.TypeOf 的参数就是 interface{}，表示可以把任何类型的变量转换为反射对象。在第 2 条定律中，reflect.Value 结构体的 Interface 方法返回的值也是 interface{}，表示可以把反射对象还原为对应的类型变量。</p></blockquote><h2 id=总结>总结</h2><p>在反射中，reflect.Value 对应的是变量的值，如果你需要进行和变量的值有关的操作，应该优先使用 reflect.Value，比如获取变量的值、修改变量的值等。reflect.Type 对应的是变量的类型，如果你需要进行和变量的类型本身有关的操作，应该优先使用 reflect.Type，比如获取结构体内的字段、类型拥有的方法集等。</p><blockquote><p>反射虽然很强大，可以简化编程、减少重复代码，但是过度使用会让你的代码变得复杂混乱。所以除非非常必要，否则尽可能少地使用它们。</p></blockquote></div><footer class=post-footer><div class=post-tags><a href=/tags/go>go</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021531496.png alt="青丝蘸白雪i - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021532231.png alt="青丝蘸白雪i - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Go语言字符串和结构体之间转换</li><li class=post-copyright-author><strong>本文作者：</strong>
青丝蘸白雪i</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/ title=Go语言字符串和结构体之间转换>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-27-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-28-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E5%8F%88%E7%88%B1%E5%8F%88%E6%81%A8%E7%9A%84unsafe/ rel=next title=Go语言又爱又恨的unsafe><i class="fa fa-chevron-left"></i> Go语言又爱又恨的unsafe</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-26-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/ rel=prev title=Go语言中make和new的区别>Go语言中make和new的区别
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>青丝蘸白雪i</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.111.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":null,"repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://b.sxz799.fun/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":true,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://waline.sxz799.fun/","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>
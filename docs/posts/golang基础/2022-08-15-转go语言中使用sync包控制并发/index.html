<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.110.0"><link rel="shortcut icon" type=image/x-icon href=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><link rel=icon type=image/x-icon href=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><link rel=apple-touch-icon sizes=180x180 href=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><meta itemprop=name content="Go语言中使用sync包控制并发"><meta itemprop=description content="好记性不如烂笔头..."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg"><meta itemprop=keywords content="go"><meta property="og:type" content="article"><meta property="og:title" content="Go语言中使用sync包控制并发"><meta property="og:description" content="好记性不如烂笔头..."><meta property="og:image" content="https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="青丝蘸白雪i"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="青丝蘸白雪i"><meta property="article:published_time" content="2022-08-15 20:41:12 +0000 UTC"><meta property="article:modified_time" content="2022-08-15 20:41:12 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.df155ae781e4bac8f4cf613fdb817af646eb609c549c9914d3e5371f95fcffa8.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:""}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91","permalink":"https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/","title":"Go语言中使用sync包控制并发","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Go语言中使用sync包控制并发 - 青丝蘸白雪i</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>青丝蘸白雪i</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description></p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>79</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#syncmutex-和-syncrwmutex>sync.Mutex 和 sync.RWMutex</a></li><li><a href=#syncwaitgroup>sync.WaitGroup</a></li><li><a href=#synccond>sync.Cond</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=青丝蘸白雪i src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg><p class=site-author-name itemprop=name>青丝蘸白雪i</p><div class=site-description itemprop=description>好记性不如烂笔头...</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>79</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>44</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/sxz799 title="Github → https://github.com/sxz799" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities title="知乎 → https://www.zhihu.com/people/qing-si-zhan-bai-xue-19/activities" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2018-12-07T16:39:01+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=141145></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=319></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-04-06T16:40:53+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021449705.jpg"><meta itemprop=name content="青丝蘸白雪i"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="青丝蘸白雪i"><meta itemprop=description content="好记性不如烂笔头..."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Go语言中使用sync包控制并发"><meta itemprop=description content="sync.Mutex 和 sync.RWMutex
如果同一块内存被多个 goroutine 同时访问，就会产生不知道谁先访问也无法预料最后结果的情况。这就是资源竞争，这块内存可以称为共享的资源。例如下面的代码"></span><header class=post-header><h1 class=post-title itemprop="name headline">Go语言中使用sync包控制并发</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-08-15 20:41:12 +0000 UTC" itemprop="dateCreated datePublished" datetime="2022-08-15 20:41:12 +0000 UTC">2022-08-15</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/go%E5%9F%BA%E7%A1%80 itemprop=url rel=index><span itemprop=name>go基础</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>2368</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title=评论><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text>评论：</span>
<span class=waline-comment-count data-path=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=syncmutex-和-syncrwmutex>sync.Mutex 和 sync.RWMutex</h3><p>如果同一块内存被多个 goroutine 同时访问，就会产生不知道谁先访问也无法预料最后结果的情况。这就是资源竞争，这块内存可以称为共享的资源。例如下面的代码</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> sum = <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#666>5</span>; i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>go</span> <span style=color:#00a000>add</span>(i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	time.<span style=color:#00a000>Sleep</span>(<span style=color:#666>2</span> <span style=color:#666>*</span> time.Second)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;和为:&#34;</span>, sum)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>add</span>(i <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add前sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>	sum <span style=color:#666>+=</span> i
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add &#34;</span>, i, <span style=color:#b44>&#34;后sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span>运行结果</span>:
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>0</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>2</span> <span>后</span>sum= <span style=color:#666>2</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>0</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>0</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>4</span> <span>后</span>sum= <span style=color:#666>7</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>1</span> <span>后</span>sum= <span style=color:#666>3</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>2</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>3</span> <span>后</span>sum= <span style=color:#666>10</span>
</span></span><span style=display:flex><span><span>和为</span>: <span style=color:#666>10</span>
</span></span></code></pre></div><p>通过上面的代码我们发现我们创建的4个协程再执行add中的语句时是有可能同时执行的,这就是资源竞争,并没有得到想要结果。那我们有没有什么办法能在同一时刻只有一个协程去读取sum呢？这就要用到sync包了。看下面的代码</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> sum = <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> mutex sync.Mutex
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#666>5</span>; i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>go</span> <span style=color:#00a000>add</span>(<span style=color:#666>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	time.<span style=color:#00a000>Sleep</span>(<span style=color:#666>2</span> <span style=color:#666>*</span> time.Second)
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;和为:&#34;</span>, sum)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>add</span>(i <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	mutex.<span style=color:#00a000>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>defer</span> mutex.<span style=color:#00a000>Unlock</span>()
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add前sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>	sum <span style=color:#666>+=</span> i
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add &#34;</span>, i, <span style=color:#b44>&#34;后sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>运行结果：</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>0</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>2</span> <span>后</span>sum= <span style=color:#666>2</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>2</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>1</span> <span>后</span>sum= <span style=color:#666>3</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>3</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>4</span> <span>后</span>sum= <span style=color:#666>7</span>
</span></span><span style=display:flex><span>add<span>前</span>sum= <span style=color:#666>7</span>
</span></span><span style=display:flex><span>add  <span style=color:#666>3</span> <span>后</span>sum= <span style=color:#666>10</span>
</span></span><span style=display:flex><span><span>和为</span>: <span style=color:#666>10</span>
</span></span></code></pre></div><p>通过上面的代码我们发现虽然协程执行的顺序并不是按照for循环中的顺序来(给出的顺序是2143 只是一种结果，如果按照for循环的顺序来应该是1234),但是没一个协程在执行add函数中的语句时别的协程是没有参与进来的，这就是互斥锁。
但是这样每次读写共享资源都要加锁，会导致性能低下，这该怎么解决呢？</p><p>现在我们分析读写这个特殊场景，有以下几种情况：</p><ul><li>写的时候不能同时读，因为这个时候读取的话可能读到脏数据（不正确的数据）；</li><li>读的时候不能同时写，因为也可能产生不可预料的结果；</li><li>读的时候可以同时读，因为数据不会改变，所以不管多少个 goroutine 读都是并发安全的。</li></ul><p>所以就可以通过读写锁 sync.RWMutex 来优化这段代码，提升性能。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> mutex sync.RWMutex
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>add</span>(i <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	mutex.<span style=color:#00a000>RLock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>defer</span> mutex.<span style=color:#00a000>RUnlock</span>()
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add前sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>	sum <span style=color:#666>+=</span> i
</span></span><span style=display:flex><span>	fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;add &#34;</span>, i, <span style=color:#b44>&#34;后sum=&#34;</span>, sum)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样多个 goroutine 可以同时读数据，不再相互等待。</p><blockquote><p>sync.Mutex 和 sync.RWMutex 都是悲观锁</p></blockquote><h3 id=syncwaitgroup>sync.WaitGroup</h3><p>细心的你可能会发现每次运行程序后输出结果前都会等待2秒，这是因为为了等待所有的协程都执行结束，不然main函数结束了程序就退出了，那有些协程可能还没开始就结束了。</p><p>但是每次都等2秒或者说如果2s的时间不够那怎么办呢？是不是应该让所有协程执行结束后就输出结果然后程序结束。</p><p>这就要用到sync包中的WaitGroup，我们先看下WaitGroup的描述。</p><p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.
A WaitGroup must not be copied after first use.</p><p>大概意思就是说在协程执行前执行一下Add方法，协程临近结束前执行一下Done方法。
在主程序中执行Wait方法就会阻塞程序，直到所有的协程都完成。
举个🌰</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#666>10000</span>; i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>(i <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>			fmt.<span style=color:#00a000>Println</span>(i)
</span></span><span style=display:flex><span>		}(i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	time.<span style=color:#00a000>Sleep</span>(<span style=color:#666>1</span> <span style=color:#666>*</span> time.Nanosecond)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码在一个for循环中执行了10000个匿名函数的协程，协程的内容是输出i
然后程序延迟1毫微秒结束，1毫微秒是时间内能输出多少个数字呢？大概率到不到10000个，那怎么才能让他在正好输出10000个数字后就停止呢？使用WaitGroup，看下面的代码改造</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> wg sync.WaitGroup
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i &lt; <span style=color:#666>10000</span>; i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		wg.<span style=color:#00a000>Add</span>(<span style=color:#666>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>(i <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>			fmt.<span style=color:#00a000>Println</span>(i)
</span></span><span style=display:flex><span>			wg.<span style=color:#00a000>Done</span>()
</span></span><span style=display:flex><span>		}(i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	wg.<span style=color:#00a000>Wait</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就能在输出10000个数字后结束程序</p><h3 id=synccond>sync.Cond</h3><p>现在我们可以在找到所有协程同时完成的时间点了那有没有办法让所有的协程同时开始呢？
在 Go 语言中，sync.WaitGroup 用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。而 sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p><p>sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。</p><p>下面我以 5 个人赛跑为例来演示 sync.Cond 的用法。在这个示例中有一个裁判，裁判要先等这 5 个人准备就绪，然后一声发令枪响，这 5 个人就可以开始跑了，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:1;-o-tab-size:1;tab-size:1><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>//5个人赛跑，1个裁判发号施令
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>race</span>() {
</span></span><span style=display:flex><span>	cond <span style=color:#666>:=</span> sync.<span style=color:#00a000>NewCond</span>(<span style=color:#666>&amp;</span>sync.Mutex{})
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>var</span> wg1, wg2 sync.WaitGroup
</span></span><span style=display:flex><span>	wg1.<span style=color:#00a000>Add</span>(<span style=color:#666>5</span>)
</span></span><span style=display:flex><span>	wg2.<span style=color:#00a000>Add</span>(<span style=color:#666>5</span>)
</span></span><span style=display:flex><span>	rand.<span style=color:#00a000>Seed</span>(time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Unix</span>())
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>1</span>; i <span style=color:#666>&lt;=</span> <span style=color:#666>5</span>; i<span style=color:#666>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>(num <span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>			log.<span style=color:#00a000>Println</span>(num, <span style=color:#b44>&#34;号已经就位&#34;</span>)
</span></span><span style=display:flex><span>			wg1.<span style=color:#00a000>Done</span>()
</span></span><span style=display:flex><span>			cond.L.<span style=color:#00a000>Lock</span>()
</span></span><span style=display:flex><span>			log.<span style=color:#00a000>Println</span>(num, <span style=color:#b44>&#34;号等待发令枪响&#34;</span>)
</span></span><span style=display:flex><span>			cond.<span style=color:#00a000>Wait</span>() <span style=color:#080;font-style:italic>//等待发令枪响
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>			cond.L.<span style=color:#00a000>Unlock</span>()
</span></span><span style=display:flex><span>			<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>				log.<span style=color:#00a000>Println</span>(num, <span style=color:#b44>&#34;号开始跑……&#34;</span>)
</span></span><span style=display:flex><span>				time.<span style=color:#00a000>Sleep</span>(time.Second <span style=color:#666>*</span> time.<span style=color:#00a000>Duration</span>(<span style=color:#666>3</span><span style=color:#666>+</span>rand.<span style=color:#00a000>Intn</span>(<span style=color:#666>4</span>)))
</span></span><span style=display:flex><span>				log.<span style=color:#00a000>Println</span>(num, <span style=color:#b44>&#34;号跑完了&#34;</span>)
</span></span><span style=display:flex><span>				wg2.<span style=color:#00a000>Done</span>()
</span></span><span style=display:flex><span>			}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		}(i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//等待所有goroutine都进入wait状态
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	wg1.<span style=color:#00a000>Wait</span>()
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		log.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;裁判已经就位，准备发令枪&#34;</span>)
</span></span><span style=display:flex><span>		log.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;比赛开始，大家准备跑&#34;</span>)
</span></span><span style=display:flex><span>		cond.<span style=color:#00a000>Broadcast</span>() <span style=color:#080;font-style:italic>//发令枪响
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	}()
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>//防止函数提前返回退出
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>	wg2.<span style=color:#00a000>Wait</span>()
</span></span><span style=display:flex><span>	log.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;所有人都跑完了&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>1.通过 sync.NewCond 函数生成一个 *sync.Cond，用于阻塞和唤醒协程；</p><p>2.然后启动 5 个协程模拟 5 个人，准备就位后调用 cond.Wait() 方法阻塞当前协程等待发令枪响，这里需要注意的是调用 cond.Wait() 方法时要加锁；</p><p>3.wg1是等待所有人准备完毕后使用 cond.Broadcast() 发号施令，wg2是等待所有人都跑完程序结束；</p><p>4.sync.Cond 有三个方法，它们分别是：</p><blockquote><p>①Wait，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</p></blockquote><blockquote><p>②Signal，唤醒一个等待时间最长的协程。</p></blockquote><blockquote><p>③Broadcast，唤醒所有等待的协程。</p></blockquote><p>注意：在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p><p>sync.Cond 和 Java 的等待唤醒机制很像，它的三个方法 Wait、Signal、Broadcast 就分别对应 Java 中的 wait、notify、notifyAll。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/go>go</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021531496.png alt="青丝蘸白雪i - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=https://raw.githubusercontent.com/sxz799/tuchuang-blog/main/img/202303/202303021532231.png alt="青丝蘸白雪i - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Go语言中使用sync包控制并发</li><li class=post-copyright-author><strong>本文作者：</strong>
青丝蘸白雪i</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/ title=Go语言中使用sync包控制并发>https://b.sxz799.fun/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8sync%E5%8C%85%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-16-%E8%BD%ACgo%E8%AF%AD%E8%A8%80context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ rel=next title=Go语言Context学习笔记><i class="fa fa-chevron-left"></i> Go语言Context学习笔记</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/golang%E5%9F%BA%E7%A1%80/2022-08-15-%E8%BD%ACgo%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8channel%E8%BF%9B%E8%A1%8Cgoroutine%E9%80%9A%E4%BF%A1/ rel=prev title=Go语言使用channel进行goroutine通信>Go语言使用channel进行goroutine通信
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>青丝蘸白雪i</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.110.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":null,"repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://b.sxz799.fun/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":true,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://waline.sxz799.fun/","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>